AWSTemplateFormatVersion: '2010-09-09'
Description: >
  AWS CloudFormation test EC2 and ECS behind Loadbalancer for a 2-tier applcation using RDS (MySQL)
Mappings:
  AWSRegion2AMI:
# ubuntu/images/hvm-ssd/ubuntu-xenial-16.04-amd64-server-20170113
    us-east-1:
      Ubuntu16x04: ami-6edd3078
    us-east-2:
      Ubuntu16x04: ami-fcc19b99
    us-west-2:
      Ubuntu16x04: ami-7c803d1c
    eu-west-1:
      Ubuntu16x04: ami-405f7226
    eu-central-1:
      Ubuntu16x04: ami-5aee2235
    ap-southeast-1:
      Ubuntu16x04: ami-b1943fd2
    ap-southeast-2:
      Ubuntu16x04: ami-fe71759d
    ap-northeast-1:
      Ubuntu16x04: ami-eb49358c
  AWSRegionECSAMI:
# amzn-ami-2016.09.f-amazon-ecs-optimized
    us-east-1:
      ecs: ami-b2df2ca4
    us-east-2:
      ecs: ami-832b0ee6
    us-west-2:
      ecs: ami-022b9262
    eu-west-1:
      ecs: ami-a7f2acc1
    eu-central-1:
      ecs: ami-ec2be583
    ap-southeast-1:
      ecs: ami-a88530cb
    ap-southeast-2:
      ecs: ami-8af8ffe9
    ap-northeast-1:
      ecs: ami-c393d6a4
  # Elasticsearch
  ## Applied at the point CloudWatch log is sent to the LogStreamer Log Group
  FilterPatternLookup:
    CloudTrail:
      Pattern: ''
    Common:
      Pattern:
        '[host, ident, authuser, date, request, status, bytes, referrer, agent]'
    FlowLogs:
      Pattern:
        '[version, account_id, interface_id, srcaddr != "-", dstaddr != "-",
        srcport != "-", dstport != "-", protocol, packets, bytes, start, end,
        action, log_status]'
    ELBLogs:
      Pattern:
        '[type, timestamp, elb, client, target, request_processing_time,
        target_processing_time, response_processing_time, elb_status_code,
        target_status_code, received_bytes, sent_bytes, request, user_agent,
        ssl_cipher, ssl_protocol, target_group_arn, trace_id]'
    Lambda:
      Pattern: '[timestamp=*Z, request_id="*-*", event]'
    Other:
      Pattern: ''
    SpaceDelimited:
      Pattern: '[]'
    ECS:
      Pattern: '"Container"'
  # http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html#enable-access-logs-console
  AWSELBAccountID:
    us-east-1:
      id: 127311923021
    us-east-2:
      id: 033677994240
    us-west-2:
      id: 797873946194
    eu-west-1:
      id: 156460612806

Outputs:
  WebsiteURLCodeDeployLB:
    Description: Website
    Value: !Join ['', [
      !If [cEnableHTTPS, 'https://', 'http://'],
      !If [cEnableDNS, !Sub 'ec2.${AWS::StackName}.al-labs.co.uk', !Sub '${CodeDeployALB.DNSName}']]
    ]
  RepoURL:
    Description: Git Repository
    Value: !GetAtt 'CodeRepo.CloneUrlSsh'
  ServiceURL:
    Description: ECS LB URL
    Value: !Join ['', [
      !If [cEnableHTTPS, 'https://', 'http://'],
      !If [cEnableDNS, !Sub 'ecs.${AWS::StackName}.al-labs.co.uk', !Sub '${CodeDeployALB.DNSName}']]
    ]
  PipelineUrl:
    Value: !Sub 'https://console.aws.amazon.com/codepipeline/home?region=${AWS::Region}#/view/${MyAppPipeline}'
  # These exported values are sent in every request by the lambda function, not sure where they get included
  # This value below is already exported but not being picked up by the lambda function
  DomainEndpoint:
    Condition: cEnableElasticSearchLogs
    Value:
      Fn::ImportValue:
        !Sub '${ElasticsearchStack}-DomainEndpointES'

Parameters:
  DBAllocatedStorage:
    ConstraintDescription: must be between 5 and 1024Gb.
    Default: 5
    Description: The size of the database (Gb)
    MaxValue: 1024
    MinValue: 5
    Type: Number
  DBClass:
    AllowedValues:
      - db.t2.large
      - db.m4.large
    ConstraintDescription: must select a valid database instance type.
    Default: db.t2.large
    Description: Database instance class
    Type: String
  DBName:
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
    Default: todo
    Description: The database name
    MaxLength: 64
    MinLength: 1
    Type: String
  DBPassword:
    AllowedPattern: '[a-zA-Z0-9]*'
    ConstraintDescription: must contain only alphanumeric characters.
    Default: password
    Description: The database admin account password
    MaxLength: 41
    MinLength: 8
    NoEcho: True
    Type: String
  DBUsername:
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
    Default: root
    Description: The database admin account username
    MaxLength: 16
    MinLength: 1
    NoEcho: True
    Type: String
  ElasticsearchLogs:
    Description: Enable/Disable Elasticsearch
    AllowedValues:
      - Enable
      - Disable
    Default: Disable
    Type: String
  ElasticsearchStack:
    Description: Elasticstack to extend
    MaxLength: 64
    MinLength: 0
    Type: String
  InstanceType:
    AllowedValues:
      - t2.micro
      - m3.medium
      - m3.large
      - m3.xlarge
      - m3.2xlarge
      - m4.large
      - m4.xlarge
      - c3.large
      - c3.xlarge
      - c3.2xlarge
      - c4.large
      - c4.xlarge
      - c4.2xlarge
    ConstraintDescription: must be a valid EC2 instance type.
    Default: c4.large
    Description: WebServer EC2 instance type
    Type: String
  InstanceCount:
    Description: Number of Amazon EC2 instances to Launch. (Must be a number between
      1 and 4).
    Type: Number
    Default: 2
    ConstraintDescription: Must be a number between 1 and 4.
    MinValue: 1
    MaxValue: 4
  InstanceMaxCount:
    Description: Maximum Number of Amazon EC2 instances in an autoscaling group. (Must
      be a number between 4 and 8)
    Type: Number
    Default: 4
    ConstraintDescription: Must be a number between 4 and 8.
    MinValue: 4
    MaxValue: 8
  InstanceMinCount:
    Description: Minimum Number of Amazon EC2 instances in an autoscaling group. (Must
      be a number between 1 and 4).
    Type: Number
    Default: 1
    ConstraintDescription: Must be a number between 1 and 4.
    MinValue: 1
    MaxValue: 4
  SSHLocation:
    Description: The IP address range that can be used to connect using SSH or RDP
      to the Amazon EC2 instances.
    Type: String
    Default: 0.0.0.0/0
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
    ConstraintDescription: Must be a valid IP CIDR range of the form x.x.x.x/x.
  ELBLogging:
    Description: Enable / Disable LoadBalancers logging
    AllowedValues:
      - Enable
      - Disable
    Default: Disable
    Type: String
  LogCloudTrail:
    Type: String
    Description: Enable / Disable CloudTrail logging
    AllowedValues:
      - Enable
      - Disable
    Default: Disable
  OperatingSystem:
    AllowedValues:
      - Ubuntu16x04
    Default: Ubuntu16x04
    Description: Operating System Type
    Type: String
  UseSpotInstances:
    Description: Enable/Disable Spot Instances to lower pricing. Warning t2.micro Instance Type does not work with spot instances. Frankfurt, Singapore, Sydney and Tokio regions currently does not support spot instances.
    AllowedValues:
      - Enable
      - Disable
    Default: Enable
    Type: String
  SpotPricing:
    Description: Price to bid on Spot Instances.
    Type: Number
    Default: 0.05
    ConstraintDescription: Must be a Positive Number between 0 and 1
    MinValue: 0
    MaxValue: 1
  KeyPairName:
    ConstraintDescription: can contain only ASCII characters.
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances
    Type: AWS::EC2::KeyPair::KeyName
  UseDNS:
    Description: Enable/Disable DNS configurations
    AllowedValues:
      - Enable
      - Disable
    Default: Enable
    Type: String
  UseHTTPS:
    Description: Enable/Disable HTTPs configuration
    AllowedValues:
      - Enable
      - Disable
    Default: Enable
    Type: String
  OperationsEmail:
    Description: EMail address to notify if there are any scaling operations
    Type: String
    AllowedPattern: (^$|([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?))
    ConstraintDescription: Must be a valid email address.
    Default: ''
  EmailApprovals:
    Description: Email used to send approval notifications
    Default: ''
    Type: String
  SlackApprovalsWebhook:
    Description: |
      Slack channel incoming webhook to send approval notifications, check
      https://api.slack.com/incoming-webhooks
      If no URL is set, slack notificaitons will be disabled/not provisioned
    Default: ''
    NoEcho: True
    Type: String
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: 'Domain Name:'
        Parameters:
          - UseDNS
      - Label:
          default: 'Database Configuration:'
        Parameters:
          - DBName
          - DBUsername
          - DBPassword
          - DBClass
          - DBAllocatedStorage
      - Label:
          default: 'Auto-Scaling Web Server Group''s Instance Configuration: '
        Parameters:
          - UseSpotInstances
          - SpotPricing
          - InstanceType
          - OperatingSystem
          - InstanceCount
          - InstanceMaxCount
          - InstanceMinCount
      - Label:
          default: 'Security: '
        Parameters:
          - KeyPairName
          - UseHTTPS
          - SSHLocation
      - Label:
          default: 'Notification: '
        Parameters:
          - OperationsEmail
          - EmailApprovals
          - SlackApprovalsWebhook
      - Label:
          default: 'Logging: '
        Parameters:
          - ELBLogging
          - ElasticsearchLogs
          - ElasticsearchStack
          - LogCloudTrail
    ParameterLabels:
      DBName:
        default: Database Name
      DBUsername:
        default: Database User Name
      DBPassword:
        default: Database Password
      DBClass:
        default: Database Instance Class
      DBAllocatedStorage:
        default: Database Storage
      KeyPairName:
        default: Key Pair Name
      UseHTTPS:
        default: Use HTTPS
      UseDNS:
        default: Use DNS
      ElasticsearchLogs:
        default: Deploy Elasticsearch
      ElasticsearchStack:
        default: Central Logging Elasticsearch Stack Name
      ELBLogging:
        default: Enable ELB Logging
      LogCloudTrail:
        default: Enable CloudTrail logging
      UseSpotInstances:
        default: Use Spot Instances
      SpotPricing:
        default: Spot Instance Bid Price
      EmailApprovals:
        default: Approval Email Address
      OperationsEmail:
        default: Notification Email Address
      SlackApprovalsWebhook:
        default: Slack Channel Webhook

Conditions:
  cEnableDNS: !Equals [!Ref UseDNS, 'Enable']
  cEnableHTTPS: !Equals [!Ref UseHTTPS, 'Enable']
  cEnableElasticSearchLogs: !Equals [!Ref ElasticsearchLogs, 'Enable']
  cEnableELBLogging: !Equals [!Ref ELBLogging, 'Enable']
  cEnableELBtoElasticSearch: !And [!Condition cEnableElasticSearchLogs, !Condition cEnableELBLogging]
  cEnableLogCloudTrail: !Equals [!Ref LogCloudTrail, 'Enable']
  cSpotPriceGreaterThanZero: !Not [!Equals [!Ref SpotPricing, 0]]
  cEnableSpotInstances: !And
    - !Equals [!Ref UseSpotInstances, 'Enable']
    - !Condition cSpotPriceGreaterThanZero
    - !Not [!Equals [!Sub '${AWS::Region}', 'eu-central-1']]
    - !Not [!Equals [!Sub '${AWS::Region}', 'ap-southeast-1']]
    - !Not [!Equals [!Sub '${AWS::Region}', 'ap-southeast-2']]
    - !Not [!Equals [!Sub '${AWS::Region}', 'ap-northeast-1']]
  cEnableApprovalEmails: !Not [!Equals [!Ref EmailApprovals, '']]
  cEnableSlackApprovals: !Not [!Equals [!Ref SlackApprovalsWebhook, '']]
  cEnableASGNotications: !Not [!Equals [!Ref OperationsEmail, '']]

# Resources documentation
# http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html
Resources:
  Networking:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: https://s3.amazonaws.com/al-cf-templates-us-east-1/infrastructure-networking.yaml
      Parameters:
        ParentStackName: !Sub '${AWS::StackName}'

  ####################################################################################
  # Start of Set Parameter Function
  ####################################################################################
  MyKey:
    Type: AWS::KMS::Key
    Properties:
      Description: Master key used by Parameter Store
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Allow administration of the key
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: '*'
            Resource: '*'
          # Allow EncryptLambda function to use the key
          - Effect: Allow
            Action:
              - kms:Encrypt
            Principal:
              AWS: !GetAtt 'LambdaRole.Arn'
            Resource: '*'
          # TODO: This can be set in the key! but we don't have it here
          - Effect: Allow
            Action:
              - kms:Decrypt
            Principal:
              AWS:
                - !GetAtt 'CodeDeployLinuxEC2InstanceRole.Arn'
                - !GetAtt 'TaskRole.Arn'
            Resource: '*'
  MyKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/${AWS::StackName}-masterkey'
      TargetKeyId: !Ref MyKey

  # Create Log Group to setup the Retention time of Lambda Logs
  EncryptLambdaLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-set-param-store'
      RetentionInDays: 1
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-Lambda-SetParamStore'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              # Allow lambda to create log group
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              # Create Log streams and write on it
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-set-param-store'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-set-param-store:*'
              # Allow Lambda Function to set values into Parameters Store in a specific name space
              - Effect: Allow
                Action:
                  - ssm:PutParameter
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.db.*'
                  # Used on AWS console to test the function ^.^
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.fn.test'
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.slack.*'
  EncryptLambda:
    Type: AWS::Lambda::Function
    DependsOn: MyKeyAlias
    Properties:
      FunctionName: !Sub '${AWS::StackName}-set-param-store'
      Handler: index.lambda_handler
      Role: !GetAtt 'LambdaRole.Arn'
      Code:
        ZipFile: |
          import base64
          import uuid
          import httplib
          import urlparse
          import json
          import boto3
          import logging
          import cfnresponse

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
            logger.info('got event{}'.format(event))
            logger.info('got context{}'.format(context))

            response = {
              'StackId': event['StackId'],
              'RequestId': event['RequestId'],
              'LogicalResourceId': event['LogicalResourceId'],
              'Status': 'SUCCESS'
            }
            status = cfnresponse.SUCCESS
            data = {}

            #Delete action is a NoOp
            if event['RequestType'] == 'Delete':
              data['message'] = 'Delete Event. Nothing to do!'
              cfnresponse.send(event, context, status, data)
              return

            # WIP
            if event['RequestType'] == 'Update':
              data['message'] = 'Update Event. Nothing to do!'
              cfnresponse.send(event, context, status, data)
              return

            try:
              ResourceProperties = event['ResourceProperties']

              # Save value into parameter store
              psClient = boto3.client('ssm')
              a = {
                'Name': ResourceProperties['ParameterStoreName'],
                'Value': ResourceProperties['Value'],
                'Type': ResourceProperties['Type'],
                'Overwrite': bool(ResourceProperties['Overwrite']) if 'Overwrite' in ResourceProperties else False,
              }

              if 'Description' in ResourceProperties:
                a['Description'] = ResourceProperties['Description']

              if 'KeyId' in ResourceProperties:
                a['KeyId'] =  ResourceProperties['KeyId']

              psClient.put_parameter(**a)

              data['message'] = 'The value was successfully encrypted'
            except Exception as e:
              logger.error(e)
              status = cfnresponse.FAILED
              data['message'] = 'Encryption Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'

            cfnresponse.send(event, context, status, data)
      Runtime: python2.7
      Timeout: 25
  StoreEncryptedDBPassword:
    Type: Custom::SetParameterStore
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      KeyId: !Sub 'alias/${AWS::StackName}-masterkey'
      ParameterStoreName: !Sub '${AWS::StackName}.db.password'
      Value: !Ref DBPassword
      Description: DataBase password
      Type: 'SecureString'
      Overwrite: True
  ####################################################################################
  # End of Set Parameter Function
  ####################################################################################

  ####################################################################################
  # Start of RDS
  ####################################################################################
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: RDS Subnet Group
      SubnetIds:
        - !GetAtt 'Networking.Outputs.privateSubnet01ID'
        - !GetAtt 'Networking.Outputs.privateSubnet02ID'
  DBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow Internal access to RDS Instances
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
      SecurityGroupIngress:
        - SourceSecurityGroupId: !Ref EcsSecurityGroup
          FromPort: 3306
          ToPort: 3306
          IpProtocol: tcp
        - SourceSecurityGroupId: !Ref CodeDeployLinuxEC2SecurityGroup
          FromPort: 3306
          ToPort: 3306
          IpProtocol: tcp
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-DB'
  DBInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      AllocatedStorage: !Ref DBAllocatedStorage
      DBInstanceClass: !Ref DBClass
      DBName: !Ref DBName
      VPCSecurityGroups: [!Ref DBSecurityGroup]
      Engine: MySQL
      MasterUserPassword: !Ref DBPassword
      MasterUsername: !Ref DBUsername
      BackupRetentionPeriod: 0 # NOTE: This disables backups and speedups the provisioning tests...!
      DBSubnetGroupName: !Ref DBSubnetGroup
  StoreDBAddress:
    Type: Custom::SetParameterStore
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      ParameterStoreName: !Sub '${AWS::StackName}.db.connectionstring'
      Value: !GetAtt 'DBInstance.Endpoint.Address'
      Description: DataBase Address
      Type: 'String'
      Overwrite: True
  StoreDBUsername:
    Type: Custom::SetParameterStore
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      ParameterStoreName: !Sub '${AWS::StackName}.db.username'
      Value: !Ref DBUsername
      Description: DataBase username
      Type: 'String'
      Overwrite: True
  StoreDBName:
    Type: Custom::SetParameterStore
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      ParameterStoreName: !Sub '${AWS::StackName}.db.name'
      Value: !Ref DBName
      Description: DataBase Name
      Type: 'String'
      Overwrite: True
  ####################################################################################
  # End of RDS
  ####################################################################################

  ####################################################################################
  # Start of ELB Logging buckets
  ####################################################################################
  ELBAccessLogsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Condition: cEnableELBLogging
    Properties:
      BucketName: !Sub '${AWS::StackName}-elb-logs'
      NotificationConfiguration:
        LambdaConfigurations:
          - Function: !GetAtt 'ELBLogsToCWLambda.Arn'
            Event: s3:ObjectCreated:*
      LifecycleConfiguration:
        Rules:
          - Id: !Sub '${AWS::StackName}-elb-logs-lifecycle'
            ExpirationInDays: 90
            Status: Enabled
            Transitions:
              - StorageClass: STANDARD_IA
                TransitionInDays: 30
              - StorageClass: GLACIER
                TransitionInDays: 60
  ELBAccessLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Condition: cEnableELBLogging
    Properties:
      Bucket: !Ref ELBAccessLogsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: ELBAccessLogsBucket
            Effect: Allow
            Resource:
              - !Sub 'arn:aws:s3:::${ELBAccessLogsBucket}/ECS-ELB/AWSLogs/${AWS::AccountId}/*'
              - !Sub 'arn:aws:s3:::${ELBAccessLogsBucket}/CodeDeploy-ELB/AWSLogs/${AWS::AccountId}/*'
            Principal:
              AWS:
                - !FindInMap [AWSELBAccountID, !Ref 'AWS::Region', id]
                - !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action:
              - s3:PutObject
  LogGroupELBLog:
    Type: AWS::Logs::LogGroup
    Condition: cEnableELBLogging
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-elblog'
      RetentionInDays: 7
  ELBLogLambdaRole:
    Type: AWS::IAM::Role
    Condition: cEnableELBLogging
    Metadata:
      Comment: ELBLogLambdaRole allows Lambda to read from S3 and write to CloudWatch.
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - 'lambda.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
  ELBLogLambdaRolePolicies:
    Type: AWS::IAM::Policy
    Condition: cEnableELBLogging
    Metadata:
      Comment: IAM Policy attached to the ELBLogLambdaRole.
    Properties:
      PolicyName: ELBLogLambdaRolePolicy
      PolicyDocument:
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
              - 'logs:DescribeLogGroups'
              - 'logs:DescribeLogStreams'
            Resource:
              - !Sub '${LogGroupELBLog.Arn}'
              - !Sub '${ELBLogsToCWLambdaLogGroup.Arn}'
          - Effect: Allow
            Action:
              - 's3:GetObject'
            Resource:
              - !Sub 'arn:aws:s3:::${AWS::StackName}-elb-logs/*'
      Roles:
        - !Ref 'ELBLogLambdaRole'
  ELBLogLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Condition: cEnableELBLogging
    Properties:
      FunctionName: !GetAtt 'ELBLogsToCWLambda.Arn'
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
  ELBLogsToCWLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Condition: cEnableELBLogging
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-ELBLogsToCWLambda'
      RetentionInDays: 1
  ELBLogsToCWLambda:
    Type: AWS::Lambda::Function
    Condition: cEnableELBLogging
    DependsOn: ELBLogLambdaRolePolicies
    Properties:
      FunctionName: !Sub '${AWS::StackName}-ELBLogsToCWLambda'
      Description: 'This code will move your ELB logs from S3 to CloudWatch. It is
        compressed, so quite hard to read. Original: github.com/awslabs/cloudwatch-logs-centralize-logs'
      Role: !GetAtt 'ELBLogLambdaRole.Arn'
      Handler: index.handler
      Code:
        # Ref: https://github.com/awslabs/cloudwatch-logs-centralize-logs
        ZipFile: |
          'use strict';
          const aws = require('aws-sdk');
          var zlib = require('zlib');
          const readline = require('readline');
          const stream = require('stream');

          const s3 = new aws.S3({ apiVersion: '2006-03-01' });
          const cloudWatchLogs = new aws.CloudWatchLogs({apiVersion: '2014-03-28'});

          exports.handler = (event, context, cb) => {
            console.log('S3 object is:', event.Records[0].s3);
            const bucket = event.Records[0].s3.bucket.name;
            const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));
            const params = {
              Bucket: bucket,
              Key: key,
            };
            s3.getObject(params, (err, data) => {
              if (err) {
                return cb(err);
              }

              //uncompressing the S3 data
              zlib.gunzip(data.Body, function(err, buffer){
                if (err) {
                  console.log('Error uncompressing data', err);
                  return cb(err);
                }

                var logData = buffer.toString('ascii');
                manageLogStreams(logData);

                cb(null, data.ContentType);
              });
            });

            function manageLogStreams (logData) {
              var describeLogStreamsParams = {
                logGroupName: process.env.LOG_GROUP,
                logStreamNamePrefix: process.env.LOG_STREAM
              }

              cloudWatchLogs.describeLogStreams (describeLogStreamsParams, (err, data) => {
                if (err) {
                  return cb(err);
                }

                if (!data.logStreams[0]) {
                  createLogStream(logData);
                } else {
                  putLogEvents(data.logStreams[0].uploadSeqToken, logData);
                }
              });
            }

            function createLogStream (logData) {
              var logStreamParams = {
                logGroupName: process.env.LOG_GROUP,
                logStreamName: process.env.LOG_STREAM
              };

              cloudWatchLogs.createLogStream(logStreamParams, (err, data) => {
                if (err) {
                  return cb(err);
                }

                putLogEvents(null, logData);
              });
            }

            function putLogEvents(seqToken, logData) {
              const MAX_BATCH_SIZE = 1048576;
              const MAX_BATCH_COUNT = 10000;
              const LOG_EVENT_OVERHEAD = 26;

              var batches = [];
              var batch = [];
              var batch_size = 0;

              var bufferStream = new stream.PassThrough();
              bufferStream.end(logData);

              var rl = readline.createInterface({
                input: bufferStream
              });

              var line_count = 0;

              rl.on('line', (line) => {
                ++line_count;

                var ts = line.split(' ', 2)[1];
                var tval = Date.parse(ts);

                var event_size = line.length + LOG_EVENT_OVERHEAD;

                batch_size += event_size;

                if(batch_size >= MAX_BATCH_SIZE || batch.length >= MAX_BATCH_COUNT) {
                  // start a new batch
                  batches.push(batch);
                  batch = [];
                  batch_size = event_size;
                }

                batch.push({
                  message: line,
                  timestamp: tval
                });
              });

              rl.on('close', () => {
                // add the final batch
                batches.push(batch);
                sendBatches(seqToken, batches);
              });
            }

            function sendBatches(seqToken, batches) {
              var count = 0;
              var batch_count = 0;

              function sendNextBatch(nextSeqToken) {
                var batch = batches.shift();
                if(batch) {
                  // send this batch
                  ++batch_count;
                  count += batch.length;
                  sendBatch(nextSeqToken, batch, sendNextBatch);
                } else {
                  // we are done
                  let msg = `Successfully put ${count} events in ${batch_count} batches`;
                  console.log(msg);
                  cb(null, msg);
                }
              }

              sendNextBatch(seqToken);
            }

            function sendBatch(seqToken, batch, next) {
              var params = {
                logEvents: batch,
                logGroupName: process.env.LOG_GROUP,
                logStreamName: process.env.LOG_STREAM
              }
              if (seqToken) {
                params['seqToken'] = seqToken;
              }

              params.logEvents.sort((a, b) => a.timestamp - b.timestamp);

              cloudWatchLogs.putLogEvents(params, (err, data) => {
                if (err) {
                  console.log('Error during put log events:', err, err.stack);
                  return cb(err, null);
                }

                console.log(`Success in putting ${params.logEvents.length} events`);
                next(data.nextSeqToken);
              });
            }
          };
      Environment:
        Variables:
          LOG_GROUP: !Sub '${AWS::StackName}-elblog'
          LOG_STREAM: 'ELB'
      Runtime: nodejs6.10
  ####################################################################################
  # End of ELB Logging buckets
  ####################################################################################

  #####################################################################################
  # Start of ECS
  #####################################################################################
  ContainerCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub '${AWS::StackName}-cluster'
  ECSAutoScalingNotifications:
    Type: AWS::SNS::Topic
    Condition: cEnableASGNotications
    Properties:
      Subscription:
        - Endpoint: !Ref OperationsEmail
          Protocol: email
  # complete example http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-ecs.html
  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !GetAtt 'Networking.Outputs.publicSubnet01ID'
        - !GetAtt 'Networking.Outputs.publicSubnet02ID'
      LaunchConfigurationName: !Ref ECSLaunchConfig
      MinSize: !Ref 'InstanceMinCount'
      MaxSize: !Ref 'InstanceMaxCount'
      DesiredCapacity: !Ref 'InstanceCount'
      MetricsCollection:
        - Granularity: 1Minute
          # No metrics specified, send all!
          # http://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_EnableMetricsCollection.html
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECS'
          PropagateAtLaunch: True
      NotificationConfiguration: !If
        - cEnableASGNotications
        - TopicARN: !Ref ECSAutoScalingNotifications
          NotificationTypes:
            - 'autoscaling:EC2_INSTANCE_LAUNCH'
            - 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR'
            - 'autoscaling:EC2_INSTANCE_TERMINATE'
            - 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR'
        - !Ref 'AWS::NoValue'
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: True
  ECSLaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        services:
          sysvint:
            awslogs:
              enabled: True
              ensureRunning: True
              files:
                - "/etc/awslogs/awslogs.conf"
        config:
          packages:
            yum:
              awslogs: []
          files:
            /etc/awslogs/awslogs.conf:
              content: !Sub |
                [general]
                state_file= /var/awslogs/agent-state
                [cloud-init-outputlog]
                file = /var/log/cloud-init-output.log
                log_group_name =  ${LogGroupCloudInit}
                log_stream_name = ecs.cloudinit.outputlog-{instance_id}
                datetime_format = %d/%b/%Y:%H:%M:%S
                [system-log]
                file = /var/log/syslog
                log_group_name =  ${LogGroupSysLog}
                log_stream_name = ecs.syslog-{instance_id}
                datetime_format = %b %d %H:%M:%S
              mode: '000400'
              owner: root
              group: root
    Properties:
      # AMI list: http://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html
      InstanceType: !Ref InstanceType
      ImageId: !FindInMap [AWSRegionECSAMI, !Ref 'AWS::Region', 'ecs']
      SpotPrice: !If [cEnableSpotInstances, !Ref SpotPricing, !Ref 'AWS::NoValue']
      KeyName: !Ref KeyPairName
      SecurityGroups: [!Ref EcsSecurityGroup]
      IamInstanceProfile: !Ref EC2InstanceProfile
      InstanceMonitoring: True
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe

          echo ECS_CLUSTER=${ContainerCluster} >> /etc/ecs/ecs.config
          yum install -y aws-cfn-bootstrap

          # We can "trap" errors and use cfn-signal to "stop" the deploy
          function error_exit
          {
            /opt/aws/bin/cfn-signal -e 1 --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
            exit 1
          }
          trap 'error_exit' ERR

          # Call CFN-INIT to process the metadata for CloudFormation Init.
          /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource ECSLaunchConfig --region ${AWS::Region}

          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
  EcsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ECS Security Group
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 31000
          ToPort: 61000
        - CidrIp: !Ref 'SSHLocation'
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECS'
  ECSALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ECS LB Security Group
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECS-LB'
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref EC2Role]
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-ECS-EC2'
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'ecs:CreateCluster'
                  - 'ecs:DeregisterContainerInstance'
                  - 'ecs:DiscoverPollEndpoint'
                  - 'ecs:Poll'
                  - 'ecs:RegisterContainerInstance'
                  - 'ecs:StartTelemetrySession'
                  - 'ecs:Submit*'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: '*'
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:GetRepositoryPolicy
                  - ecr:DescribeRepositories
                  - ecr:ListImages
                  - ecr:DescribeImages
                  - ecr:BatchGetImage
                Resource: '*'
  ECSServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-ECS-Service'
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                  - 'elasticloadbalancing:DeregisterTargets'
                  - 'elasticloadbalancing:Describe*'
                  - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                  - 'elasticloadbalancing:RegisterTargets'
                  - 'ec2:Describe*'
                  - 'ec2:AuthorizeSecurityGroupIngress'
                Resource: '*'
  ECSALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${AWS::StackName}-ECS-LB'
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: 30
        - !If [cEnableELBLogging, {Key: access_logs.s3.enabled, Value: True}, !Ref 'AWS::NoValue']
        - !If [cEnableELBLogging, {Key: access_logs.s3.bucket, Value: !Ref ELBAccessLogsBucket}, !Ref 'AWS::NoValue']
        - !If [cEnableELBLogging, {Key: access_logs.s3.prefix, Value: 'ECS-ELB'}, !Ref 'AWS::NoValue']
      Subnets:
        - !GetAtt 'Networking.Outputs.publicSubnet01ID'
        - !GetAtt 'Networking.Outputs.publicSubnet02ID'
      SecurityGroups: [!Ref ECSALBSecurityGroup]
      Tags:
        - Key: custom:cloudformation:depends-on
          Value: !If [cEnableELBLogging, !Ref ELBAccessLogsBucketPolicy, !Ref 'AWS::NoValue']
  ECSTGMyApp:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPath: /
      Name: !Sub '${AWS::StackName}-MyApp'
      Port: 3000
      Protocol: HTTP
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ECSTGMyApp
      LoadBalancerArn: !Ref ECSALB
      Port: 80
      Protocol: HTTP
  MyRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub '${AWS::StackName}-myapp'
      RepositoryPolicyText:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowPushPull
            Effect: Allow
            Principal:
              AWS:
                - !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action:
              - ecr:GetDownloadUrlForLayer
              - ecr:BatchGetImage
              - ecr:BatchCheckLayerAvailability
              - ecr:PutImage
              - ecr:InitiateLayerUpload
              - ecr:UploadLayerPart
              - ecr:CompleteLayerUpload
  # Crate Log Group to setup the retention time of ECS task logs
  ECSTasksLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-ecs'
      RetentionInDays: 1
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-myapp-task-role'
      AssumeRolePolicyDocument:
        Statement:
          - Sid: '1'
            Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        # Allow describe parameters to automate config process
        - PolicyName: parameter-store-list
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:DescribeParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:*'
        - PolicyName: parameter-store-db
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.db.*'
        - PolicyName: parameter-store-app
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                  - ssm:PutParameter
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.app.*'
  ECSScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref ECSAutoScalingGroup
      Cooldown: 60
      ScalingAdjustment: 1
  ECSScaleDownPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref ECSAutoScalingGroup
      Cooldown: 60
      ScalingAdjustment: -1
  CPUAlarmHigh:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: Scale-up ECS cluster if CPU > 90% for 10 minutes
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 90
      AlarmActions: [!Ref ECSScaleUpPolicy]
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref ECSAutoScalingGroup
      ComparisonOperator: GreaterThanThreshold
  CPUAlarmLow:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: Scale-down ECS cluster if CPU < 70% for 10 minutes
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 70
      AlarmActions: [!Ref ECSScaleDownPolicy]
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref ECSAutoScalingGroup
      ComparisonOperator: LessThanThreshold
  #####################################################################################
  # End of ECS
  #####################################################################################

  #####################################################################################
  # Start of CI/CD
  #####################################################################################
  QAGroup:
    Type: AWS::IAM::Group
    Properties:
      GroupName: !Sub '${AWS::StackName}-QA'
      ManagedPolicyArns: ['arn:aws:iam::aws:policy/IAMReadOnlyAccess', 'arn:aws:iam::aws:policy/IAMUserSSHKeys']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Pull repo
              - Effect: Allow
                Action:
                  - codecommit:BatchGetRepositories
                  - codecommit:List*
                Resource: '*'
              - Effect: Allow
                Action:
                  - codecommit:Get*
                  - codecommit:GitPull
                Resource:
                  - !Sub 'arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp'
              - Effect: Allow
                Action:
                  - 'codepipeline:GetPipeline'
                  - 'codepipeline:GetPipelineState'
                  - 'codepipeline:GetPipelineExecution'
                Resource:
                  # - !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId):*'
                  - !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}'
              - Effect: Allow
                Action:
                  - 'codepipeline:PutApprovalResult'
                Resource:
                  - !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}:pm-MyApp/ApprovalProduction/QAApproval'
  DevGroup:
    Type: AWS::IAM::Group
    Properties:
      GroupName: !Sub '${AWS::StackName}-Dev'
      ManagedPolicyArns: ['arn:aws:iam::aws:policy/IAMReadOnlyAccess', 'arn:aws:iam::aws:policy/IAMUserSSHKeys']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # List repo
              - Effect: Allow
                Action:
                  - codecommit:BatchGetRepositories
                  - codecommit:List*
                Resource: '*'
              # Pull repo
              - Effect: Allow
                Action:
                  - codecommit:Get*
                  - codecommit:GitPull
                  - codecommit:GitPush
                Resource:
                  - !Sub 'arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp'
  CodeRepo:
    Type: AWS::CodeCommit::Repository
    Properties:
      RepositoryName: !Sub '${AWS::StackName}-myapp'
      RepositoryDescription: A code repo for the app...
  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-CodeBuild'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: [codebuild.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              # Login to ECR
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: '*'
              # Publish to ECR
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:CompleteLayerUpload
                  - ecr:InitiateLayerUpload
                  - ecr:PutImage
                  - ecr:UploadLayerPart
                Resource:
                  # TODO: paramenterize pm=test => ImageName
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/${AWS::StackName}-myapp'
              # Pull repo
              - Effect: Allow
                Action:
                  - codecommit:GitPull
                Resource:
                  # TODO: paramenterize pm=test => RepositoryName
                  - !Sub 'arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp'
              # Write build logs
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  # TODO: paramenterize pm=test => ProjectName
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp:log-stream'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp:log-stream:*'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-test:log-stream'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-test:log-stream:*'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-integration-test:log-stream'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-integration-test:log-stream:*'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-image:log-stream'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${AWS::StackName}-myapp-image:log-stream:*'
  MyAppBuildArtifact:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub '${AWS::StackName}-myapp'
      Description: A description about my project
      ServiceRole: !GetAtt 'CodeBuildRole.Arn'
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # List of Bukd Environments
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/nodejs:7.0.0
      Source:
        Location: !GetAtt 'CodeRepo.CloneUrlHttp'
        Type: CODEPIPELINE
        BuildSpec: !Sub |
          version: 0.1
          phases:
            build:
              commands:
                - echo Install NodeJS dependencies...
                - npm install --only=prod
          artifacts:
            files:
              - '**/*' # All files recursively
      TimeoutInMinutes: 300 # 5min
  MyAppTestAartifact:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub '${AWS::StackName}-myapp-test'
      Description: A description about my project
      ServiceRole: !GetAtt 'CodeBuildRole.Arn'
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # List of Bukd Environments
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/nodejs:7.0.0
      Source:
        Location: !GetAtt 'CodeRepo.CloneUrlHttp'
        Type: CODEPIPELINE
        BuildSpec: !Sub |
          version: 0.1
          phases:
            build:
              commands:
                - echo Install NodeJS dev/test dependencies...
                - npm install --only=dev
                - npm test
      TimeoutInMinutes: 300 # 5min
  MyAppIntegrationTestAartifact:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub '${AWS::StackName}-myapp-integration-test'
      Description: A description about my project
      ServiceRole: !GetAtt 'CodeBuildRole.Arn'
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # List of Bukd Environments
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/nodejs:7.0.0
        EnvironmentVariables:
          - Name: API_URL
            Value: !Sub 'http://${ECSALB.DNSName}/api'
          - Name: DB_CONNECTIONSTRING
            Value: !Sub '${DBInstance.Endpoint.Address}'
          - Name: DB_USERNAME
            Value: !Sub '${DBUsername}'
          - Name: DB_PASSWORD
            Value: !Sub '${DBPassword'
          - Name: DB_NAME
            Value: !Sub '${DBName}'
      Source:
        Location: !GetAtt 'CodeRepo.CloneUrlHttp'
        Type: CODEPIPELINE
        BuildSpec: !Sub |
          version: 0.1
          phases:
            build:
              commands:
                - echo integration tests...
                - npm install --only=dev
                - npm run integration-tests
      TimeoutInMinutes: 300 # 5min
  MyAppBuildDockerImage:
    Type: AWS::CodeBuild::Project
    DependsOn: [CodeRepo, CodeBuildRole]
    Properties:
      Name: !Sub '${AWS::StackName}-myapp-image'
      Description: A description about my project
      ServiceRole: !GetAtt 'CodeBuildRole.Arn'
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        # Info: http://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        # http://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref.html
        Image: aws/codebuild/docker:1.12.1
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: IMAGE_REPO_NAME
            Value: !Sub '${AWS::StackName}-myapp'
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
      Source:
        Location: !GetAtt 'CodeRepo.CloneUrlHttp'
        Type: CODEPIPELINE
      TimeoutInMinutes: 300 # 5min
  CodeDeployLinuxEC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable HTTP access via port 80 and SSH access.
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref 'SSHLocation'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeDeploy'
  CodeDeployLinuxEC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-CodeDeploy-EC2'
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - ec2:*
                  - codedeploy:*
                  - autoscaling:Describe*
                  - cloudformation:Describe*
                  - cloudformation:GetTemplate
                  - s3:Get*
                  - codepipeline:*
                  - rds:DescribeDBInstances
                Resource: '*'
              # Allow fetch from Parameters Store in a specific name space
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.db.*'
              # Allow describe parameters to automate config process
              - Effect: Allow
                Action:
                  - ssm:DescribeParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:*'
      Path: /
  CodeDeployLinuxEC2InstanceRoleInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref CodeDeployLinuxEC2InstanceRole]
  CodeDeployTrustRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-CodeDeploy'
      AssumeRolePolicyDocument:
        Statement:
          - Sid: '1'
            Effect: Allow
            Principal:
              Service: [codedeploy.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-CodeDeploy-policy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Allow CodeDeploy to deploy code into EC2
              - Effect: Allow
                Action:
                  - ec2:*
                  - autoscaling:* # something is required for CodeDeployDefault.AllAtOnce
                Resource: '*'
      Path: /
  EC2AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !GetAtt 'Networking.Outputs.publicSubnet01ID'
        - !GetAtt 'Networking.Outputs.publicSubnet02ID'
      LaunchConfigurationName: !Ref EC2LaunchConfig
      MinSize: !Ref 'InstanceMinCount'
      MaxSize: !Ref 'InstanceMaxCount'
      DesiredCapacity: !Ref 'InstanceCount'
      TargetGroupARNs: [!Ref CodeDeployTG]
      MetricsCollection:
        - Granularity: 1Minute
          # No metrics specified, send all!
          # http://docs.aws.amazon.com/AutoScaling/latest/APIReference/API_EnableMetricsCollection.html
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeDeploy'
          PropagateAtLaunch: True
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: True
  LogGroupAppLog:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-applog'
      RetentionInDays: 7
  LogGroupAppErrorLog:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-apperr'
      RetentionInDays: 7
  LogGroupCloudInit:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-cloudinitoutput'
      RetentionInDays: 7
  LogGroupSysLog:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-syslog'
      RetentionInDays: 7
  EC2LaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        services:
          sysvint:
            codedeploy-agent:
              enabled: True
              ensureRunning: True
        config:
          packages:
            apt:
              mysql-client: []
              unzip: []
              libwww-perl: []
              libdatetime-perl: []
          files:
            /tmp/cwlogs/logstreams.conf:
              content: !Sub |
                [general]
                state_file= /var/awslogs/agent-state
                [nodejs-serverlog]
                file = /tmp/server.log
                log_group_name =  ${LogGroupAppLog}
                log_stream_name = nodejs.serverlog-{instance_id}
                datetime_format = %d/%b/%Y:%H:%M:%S
                [nodejs-errorlog]
                file = /tmp/server.err
                log_group_name =  ${LogGroupAppErrorLog}
                log_stream_name = nodejs.errorlog-{instance_id}
                datetime_format = %d/%b/%Y:%H:%M:%S
                [cloud-init-outputlog]
                file = /var/log/cloud-init-output.log
                log_group_name =  ${LogGroupCloudInit}
                log_stream_name = cloudinit.outputlog-{instance_id}
                datetime_format = %d/%b/%Y:%H:%M:%S
                [system-log]
                file = /var/log/syslog
                log_group_name =  ${LogGroupSysLog}
                log_stream_name = syslog-{instance_id}
                datetime_format = %b %d %H:%M:%S
              mode: '000400'
              owner: root
              group: root
            /lib/systemd/system/awslogs.service:
              content: |
                [Unit]
                Description=The CloudWatch Logs agent
                After=network.target
                [Service]
                Restart=always
                TimeoutSec=infinity
                ExecStart=/var/awslogs/bin/awslogs-agent-launcher.sh
                [Install]
                WantedBy=multi-user.target
              mode: '000400'
              owner: root
              group: root
            /tmp/aws_monitoring.sh:
              content: |
                #!/usr/bin/env bash
                set -xu
                (crontab -l 2>/dev/null; echo '*/1 * * * * /home/ubuntu/aws-scripts-mon/mon-put-instance-data.pl --mem-util --disk-space-util --disk-path=/ --auto-scaling=only --from-cron') | crontab -
              mode: '000500'
              owner: root
              group: root
    Properties:
      ImageId: !FindInMap [AWSRegion2AMI, !Ref 'AWS::Region', !Ref OperatingSystem]
      SpotPrice: !If [cEnableSpotInstances, !Ref SpotPricing, !Ref 'AWS::NoValue']
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyPairName
      SecurityGroups: [!Ref CodeDeployLinuxEC2SecurityGroup]
      IamInstanceProfile: !Ref CodeDeployLinuxEC2InstanceRoleInstanceProfile
      InstanceMonitoring: True
      UserData:
        'Fn::Base64': !Sub |
          #!/bin/bash -ex

          # We can "trap" errors and use cfn-signal to "stop" the deploy
          function error_exit
          {
            cfn-signal -e 1 --stack ${AWS::StackName} --resource EC2AutoScalingGroup --region ${AWS::Region}
            exit 1
          }

          trap 'error_exit' ERR

          # Update repo and get tool dependencies
          apt-get update
          apt-get install -y python-pip ruby

          # Intall CloudFormation tools....
          pip install https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-latest.tar.gz

          # AWS CLI Tools are used to get parameters from parameter store.
          pip install awscli
          aws configure set region ${AWS::Region}

          # Install the AWS CodeDeploy Agent.
          cd /home/ubuntu
          curl -O https://aws-codedeploy-${AWS::Region}.s3.amazonaws.com/latest/install
          chmod +x ./install
          ./install auto

          # https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions
          curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -
          apt-get install -y nodejs

          apt install -y

          # Call CFN-INIT to process the metadata for CloudFormation Init. Since ubuntu does not have the tools installed, we install the CFN Bootstrap in the previous step.\n,
          cfn-init -v --stack ${AWS::StackName} --resource EC2LaunchConfig --region ${AWS::Region}

          #Download and Install the Cloudwatch Logs agent.
          curl -O https://s3.amazonaws.com/aws-cloudwatch/downloads/latest/awslogs-agent-setup.py
          python awslogs-agent-setup.py -n -r ${AWS::Region} -c /tmp/cwlogs/logstreams.conf

          #Start the Cloudwatch logs agent service using the SYSTEMD Unit file created by cloudformation Init.
          systemctl enable awslogs.service
          systemctl start awslogs.service

          #Download and Install the CloudWatch monitoring Script \n,
          curl -O http://aws-cloudwatch.s3.amazonaws.com/downloads/CloudWatchMonitoringScripts-1.2.1.zip
          unzip CloudWatchMonitoringScripts-1.2.1.zip
          rm CloudWatchMonitoringScripts-1.2.1.zip
          cd /tmp/
          sudo ./aws_monitoring.sh
          rm ./aws_monitoring.sh

          # All is well, so signal AutoScalingGroup.
          $(which cfn-signal) -e 0 --stack ${AWS::StackName} --resource EC2AutoScalingGroup --region ${AWS::Region}
  CodeDeployALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: CodeDeploy LB Security Group
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeDeploy-LB'
  CodeDeployALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${AWS::StackName}-CodeDeploy-LB'
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: 30
        - !If [cEnableELBLogging, {Key: access_logs.s3.enabled, Value: True}, !Ref 'AWS::NoValue']
        - !If [cEnableELBLogging, {Key: access_logs.s3.bucket, Value: !Ref ELBAccessLogsBucket}, !Ref 'AWS::NoValue']
        - !If [cEnableELBLogging, {Key: access_logs.s3.prefix, Value: 'CodeDeploy-ELB'}, !Ref 'AWS::NoValue']
      Subnets:
        - !GetAtt 'Networking.Outputs.publicSubnet01ID'
        - !GetAtt 'Networking.Outputs.publicSubnet02ID'
      SecurityGroups: [!Ref CodeDeployALBSecurityGroup]
      Tags:
        - Key: custom:cloudformation:depends-on
          Value: !If [cEnableELBLogging, !Ref ELBAccessLogsBucketPolicy, !Ref 'AWS::NoValue']
  CodeDeployTG:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AWS::StackName}-CodeDeployTG'
      Port: 3000
      Protocol: HTTP
      VpcId: !GetAtt 'Networking.Outputs.VPCID'
  CodeDeployALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref CodeDeployTG
      LoadBalancerArn: !Ref CodeDeployALB
      Port: 80
      Protocol: HTTP
  MyAppDeployApplication:
    Type: AWS::CodeDeploy::Application
  MyAppDeployApplicationmentGroup:
    Type: AWS::CodeDeploy::DeploymentGroup
    Properties:
      ApplicationName: !Ref MyAppDeployApplication
      DeploymentConfigName: 'CodeDeployDefault.HalfAtATime'
      AutoScalingGroups: [!Ref EC2AutoScalingGroup]
      ServiceRoleArn: !GetAtt 'CodeDeployTrustRole.Arn'
  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-CodePipelineServiceRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: [codepipeline.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Pull repo
              - Effect: Allow
                Action:
                  - codecommit:BatchGetRepositories
                  - codecommit:Get*
                  - codecommit:GitPull
                  - codecommit:List*
                  - codecommit:UploadArchive
                Resource:
                  # TODO: paramenterize pm=test => RepositoryName
                  - !Sub 'arn:aws:codecommit:${AWS::Region}:${AWS::AccountId}:${AWS::StackName}-myapp'
              - Effect: Allow
                Action:
                  - ecr:BatchGetImage
                Resource:
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/${AWS::StackName}-myapp'
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                  - cloudformation:*
                  - iam:PassRole
                Resource: '*'
              - Effect: Allow
                Action:
                  - codedeploy:*
                Resource: '*'
  ArtifactStoreS3Location:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      BucketName: !Sub '${AWS::StackName}-codepipeline-artifacts'
  ArtifactStoreS3LocationPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ArtifactStoreS3Location
      PolicyDocument:
        Statement:
          - Effect: Allow
            Action:
              - s3:*
            Resource:
              - !Sub 'arn:aws:s3:::${AWS::StackName}-codepipeline-artifacts'
              - !Sub 'arn:aws:s3:::${AWS::StackName}-codepipeline-artifacts/*'
            Principal: '*'
  CloudFormationExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-CloudFormationExecutionRole'
      AssumeRolePolicyDocument:
        Statement:
          - Sid: '1'
            Effect: Allow
            Principal:
              Service: [cloudformation.amazonaws.com]
            Action: ['sts:AssumeRole']
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Resource: '*'
                Effect: Allow
                Action:
                  - ecs:*
                  - ecr:*
                  - iam:*
                  - application-autoscaling:*
                  - cloudwatch:PutMetricAlarm
                  - cloudwatch:DeleteAlarms
  ApprovalTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub '${AWS::StackName}-approvals'
      TopicName: !Sub '${AWS::StackName}-approvals'
  ApprovalTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      # http://docs.aws.amazon.com/sns/latest/dg/AccessPolicyLanguage_SpecialInfo.html
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          # Allow Pipeline to publish into approvals topic
          - Effect: Allow
            Principal: # '*'
              AWS:
                - !Sub '${CodePipelineServiceRole.Arn}'
            Action:
              - 'sns:Publish'
            Resource:
              - !Ref ApprovalTopic
      Topics:
        - !Ref ApprovalTopic
  QAEmailGroup:
    Type: AWS::SNS::Subscription
    Condition: cEnableApprovalEmails
    Properties:
      Endpoint: !Sub '${EmailApprovals}'
      Protocol: email
      TopicArn: !Ref ApprovalTopic
  MyAppPipeline:
    Type: AWS::CodePipeline::Pipeline
    DependsOn:
      - ContainerCluster
      - ECSTGMyApp
      - ECSServiceRole
      - DBInstance
    Properties:
      Name: !Sub '${AWS::StackName}-MyApp'
      RoleArn: !GetAtt 'CodePipelineServiceRole.Arn'
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Version: 1
                Provider: CodeCommit
              OutputArtifacts:
                - Name: SourceOutput
              Configuration:
                RepositoryName: !GetAtt 'CodeRepo.Name'
                BranchName: master
        - Name: Build
          Actions:
            - Name: BuildArtifact
              InputArtifacts:
                - Name: SourceOutput
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              OutputArtifacts:
                - Name: MyAppBuild
              Configuration:
                ProjectName: !Ref MyAppBuildArtifact
              RunOrder: 1
            - Name: TestArtifact
              InputArtifacts:
                - Name: MyAppBuild
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              Configuration:
                ProjectName: !Ref MyAppTestAartifact
              RunOrder: 2
            - Name: BuildDockerImage
              InputArtifacts:
                - Name: SourceOutput
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              OutputArtifacts:
                - Name: DockerImageOutput
              Configuration:
                ProjectName: !Ref MyAppBuildDockerImage
        - Name: Beta
          Actions:
            - Name: BetaEC2
              InputArtifacts:
                - Name: MyAppBuild
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CodeDeploy
              Configuration:
                ApplicationName: !Ref MyAppDeployApplication
                DeploymentGroupName: !Ref MyAppDeployApplicationmentGroup
            - Name: BetaECS
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation
              Configuration:
                ChangeSetName: Deploy
                ActionMode: CREATE_UPDATE
                # StackName: !Ref StackName
                StackName: !Sub '${AWS::StackName}-MyApp-Service'
                Capabilities: CAPABILITY_NAMED_IAM
                # TemplatePath: Template::cloudformation.template.myapp.yaml
                TemplatePath: SourceOutput::cloudformation/myapp.template.yaml
                RoleArn: !GetAtt 'CloudFormationExecutionRole.Arn'
                # Can't be a YAML object:  Value of property Configuration must be an object with String (or simple type) properties
                # ParameterOverrides
                #   ECSTGMyApp: !Ref ECSTGMyApp
                #   ECSServiceRole: !Ref ECSServiceRole
                #   DBAddress: !GetAtt 'DBInstance.Endpoint.Address'
                ParameterOverrides: !Sub |
                  {
                    "ParamsPrefix": "${AWS::StackName}",
                    "Cluster": "${ContainerCluster}",
                    "CloudwatchLogsGroup": "${ECSTasksLogsGroup}",
                    "DockerImageTag": { "Fn::GetParam" : ["DockerImageOutput", "build.json", "tag"] },
                    "DockerImage": "${AWS::StackName}-myapp",
                    "TaskRole": "${TaskRole}",
                    "ECSTGMyApp": "${ECSTGMyApp}",
                    "ECSServiceRole": "${ECSServiceRole}",
                    "DBAddress": "${DBInstance.Endpoint.Address}"
                  }
              InputArtifacts:
                - Name: DockerImageOutput
                - Name: SourceOutput
        - Name: IntegrationTests
          Actions:
            - Name: HTTP
              InputArtifacts:
                - Name: MyAppBuild
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              # OutputArtifacts:
              #  - Name: MyAppBuild
              Configuration:
                ProjectName: !Ref MyAppIntegrationTestAartifact
        - Name: ApprovalProduction
          Actions:
            - Name: QAApproval
              ActionTypeId:
                Category: Approval
                Owner: AWS
                Version: 1
                Provider: Manual
              Configuration:
                NotificationArn: !Ref ApprovalTopic
                CustomData: !Sub 'Approval or Reject this change after running Exploratory Tests: http://${CodeDeployALB.DNSName}/'
      ArtifactStore:
        Type: S3
        Location: !Ref ArtifactStoreS3Location
  #####################################################################################
  # End of CI/CD
  #####################################################################################

  #####################################################################################
  # Start of Public DNS
  #####################################################################################
  CodeDeployLBCertifcate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub 'ec2.${AWS::StackName}.al-labs.co.uk'
      DomainValidationOptions:
        - DomainName: !Sub 'ec2.${AWS::StackName}.al-labs.co.uk'
          ValidationDomain: 'al-labs.co.uk'
    Condition: cEnableHTTPS
  ECSLBCertifcate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub 'ecs.${AWS::StackName}.al-labs.co.uk'
      DomainValidationOptions:
        - DomainName: !Sub 'ecs.${AWS::StackName}.al-labs.co.uk'
          ValidationDomain: 'al-labs.co.uk'
    Condition: cEnableHTTPS
  CodeDeployALBHTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref CodeDeployTG
      LoadBalancerArn: !Ref CodeDeployALB
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref CodeDeployLBCertifcate
    Condition: cEnableHTTPS
  ALBHTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ECSTGMyApp
      LoadBalancerArn: !Ref ECSALB
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref ECSLBCertifcate
    Condition: cEnableHTTPS
  CodeDeployDNSRecord:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneName: al-labs.co.uk.
      Comment: Zone apex alias targeted to myELB LoadBalancer.
      RecordSets:
        # One subdoamin for each type
        - Name: !Sub 'ec2.${AWS::StackName}.al-labs.co.uk.'
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt 'CodeDeployALB.CanonicalHostedZoneID'
            DNSName: !GetAtt 'CodeDeployALB.DNSName'
        - Name: !Sub 'ecs.${AWS::StackName}.al-labs.co.uk.'
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt 'ECSALB.CanonicalHostedZoneID'
            DNSName: !GetAtt 'ECSALB.DNSName'
    Condition: cEnableDNS
  #####################################################################################
  # End of Public DNS
  #####################################################################################
  #####################################################################################
  # Start of CloudTrail to CloudWatch
  #####################################################################################
  # Mapping Log groups to the Lambda that ships them to Elasticsearch
  Trail:
    DependsOn: TrailBucketPolicy
    Condition: cEnableLogCloudTrail
    Properties:
      CloudWatchLogsLogGroupArn: !GetAtt 'TrailLogGroup.Arn'
      CloudWatchLogsRoleArn: !GetAtt 'TrailLogGroupRole.Arn'
      IncludeGlobalServiceEvents: True
      IsLogging: True
      IsMultiRegionTrail: True
      S3BucketName: !Ref TrailBucket
    Type: AWS::CloudTrail::Trail
  TrailBucket:
    DeletionPolicy: Retain
    Condition: cEnableLogCloudTrail
    Properties: {}
    Type: AWS::S3::Bucket
  TrailBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Condition: cEnableLogCloudTrail
    Properties:
      Bucket: !Ref TrailBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action: s3:GetBucketAcl
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Resource: !Sub 'arn:aws:s3:::${TrailBucket}'
          - Action: s3:PutObject
            Condition:
              StringEquals:
                s3:x-amz-acl: bucket-owner-full-control
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Resource: !Sub 'arn:aws:s3:::${TrailBucket}/AWSLogs/${AWS::AccountId}/*'
  TrailLogGroup:
    Properties:
      LogGroupName: !Sub '/aws/cloudtrail/${AWS::StackName}'
      RetentionInDays: 7
    Type: AWS::Logs::LogGroup
    Condition: cEnableLogCloudTrail
  TrailLogGroupRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
        Version: '2012-10-17'
      Policies:
        - PolicyDocument:
            Statement:
              - Action: logs:CreateLogStream
                Effect: Allow
                Resource: !GetAtt 'TrailLogGroup.Arn'
              - Action:
                  - logs:PutLogEvents
                Effect: Allow
                Resource: !GetAtt 'TrailLogGroup.Arn'
            Version: '2012-10-17'
          PolicyName: cloudtrail-policy
    Type: AWS::IAM::Role
    Condition: cEnableLogCloudTrail
  #####################################################################################
  # End of CloudTrail to CloudWatch
  #####################################################################################
  #####################################################################################
  # Start of Elasticsearch logging domain
  # Logs => CloudWatch logs => CloudWatch/ LogStreamer which triggers lambda
  #####################################################################################
  LambdaInvokePermission:
    Condition: cEnableElasticSearchLogs
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref LogStreamer
      Principal: !Sub 'logs.${AWS::Region}.amazonaws.com'
      SourceAccount: !Ref AWS::AccountId
    Type: AWS::Lambda::Permission

  ## Mapping Log groups to the Lambda that ships them to Elasticsearch
  LogGrouptoLambdaMappingCloudTrail:
    Condition: cEnableElasticSearchLogs
    DependsOn: LambdaInvokePermission
    Properties:
      DestinationArn: !GetAtt 'LogStreamer.Arn'
      FilterPattern: !FindInMap [FilterPatternLookup, CloudTrail, Pattern]
      LogGroupName: !Ref TrailLogGroup
    Type: AWS::Logs::SubscriptionFilter

  LogGrouptoLambdaMappingFlowLogs:
    Condition: cEnableElasticSearchLogs
    DependsOn: LambdaInvokePermission
    Properties:
      DestinationArn: !GetAtt 'LogStreamer.Arn'
      FilterPattern: !FindInMap [FilterPatternLookup, FlowLogs, Pattern]
      LogGroupName: !Ref VPCFlowLogsLogGroup
    Type: AWS::Logs::SubscriptionFilter

  LogGrouptoLambdaMappingELBLogs:
    Type: AWS::Logs::SubscriptionFilter
    DependsOn: LambdaInvokePermission
    Condition: cEnableELBtoElasticSearch
    Properties:
      DestinationArn: !GetAtt 'LogStreamer.Arn'
      FilterPattern: !FindInMap [FilterPatternLookup, ELBLogs, Pattern]
      LogGroupName: !Sub '${AWS::StackName}-elblog'

  LogRole:
    Condition: cEnableElasticSearchLogs
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - ec2.amazonaws.com
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - logs:Create*
                  - logs:PutLogEvents
                  - s3:GetObject
                Effect: Allow
                Resource:
                  - arn:aws:logs:*:*:*
                  - arn:aws:s3:::*
            Version: '2012-10-17'
          PolicyName: LogRolePolicy
    Type: AWS::IAM::Role

  LogRoleInstanceProfile:
    Condition: cEnableElasticSearchLogs
    Properties:
      Path: /
      Roles:
        - !Ref LogRole
    Type: AWS::IAM::InstanceProfile

  # Exported so service stacks can stream logs to it.
  LogStreamer:
    Condition: cEnableElasticSearchLogs
    Properties:
      Code:
        S3Bucket: !Sub 'solutions-${AWS::Region}'
        S3Key: centralized-logging/v1/centralizedLoggingDownload.zip
      Description: Lambda function for moving log data to AES.
      Handler: index.handler
      Role: !GetAtt 'LogStreamerRole.Arn'
      Runtime: nodejs4.3
      Timeout: 300
    Type: AWS::Lambda::Function
  LogStreamerRole:
    Condition: cEnableElasticSearchLogs
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}*'
              - Effect: Allow
                Action:
                  - es:ESHttpPost
                Resource: arn:aws:es:*:*:*
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                  - Cloudformation:ListStackResources
                Resource: !Sub 'arn:aws:cloudformation:${AWS::Region}:${AWS::AccountId}*'
            Version: '2012-10-17'
          PolicyName: My_Lambda_Function_Permissions
    Type: AWS::IAM::Role
  MyFlowLog:
    Condition: cEnableElasticSearchLogs
    Properties:
      DeliverLogsPermissionArn: !GetAtt 'flowlogsRole.Arn'
      LogGroupName: !Ref VPCFlowLogsLogGroup
      ResourceId: !GetAtt 'Networking.Outputs.VPCID'
      ResourceType: VPC
      TrafficType: ALL
    Type: AWS::EC2::FlowLog

  VPCFlowLogsLogGroup:
    Condition: cEnableElasticSearchLogs
    Properties:
      RetentionInDays: 7
    Type: AWS::Logs::LogGroup
  flowlogsRole:
    Condition: cEnableElasticSearchLogs
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - vpc-flow-logs.amazonaws.com
        Version: 2012-10-17
      Path: /
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                  - logs:PutLogEvents
                Effect: Allow
                Resource: '*'
            Version: '2012-10-17'
          PolicyName: LogRolePolicy
    Type: AWS::IAM::Role
  ###########################################
  # End of Elasticsearch logging domain
  ###########################################
  SlackLambdaLogsGroup:
    Type: AWS::Logs::LogGroup
    Condition: cEnableSlackApprovals
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-slack-notifications'
      RetentionInDays: 1
  SlackLambdaRole:
    Type: AWS::IAM::Role
    Condition: cEnableSlackApprovals
    Properties:
      RoleName: !Sub '${AWS::StackName}-slack-notifications'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Statement:
              # Allow lambda to create log group
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              # Create Log streams and write on it
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-slack-notifications'
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-slack-notifications:*'
              # Allow lambda to use KMS to decrypt Env Vars
              - Effect: Allow
                Action:
                  - kms:Decrypt
                Resource: '*'
              - Effect: Allow
                Action:
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}.slack.*'
  StoreEncryptedSlackWebhook:
    Type: Custom::SetParameterStore
    Condition: cEnableSlackApprovals
    Properties:
      ServiceToken: !GetAtt 'EncryptLambda.Arn'
      KeyId: !Sub 'alias/${AWS::StackName}-masterkey'
      ParameterStoreName: !Sub '${AWS::StackName}.slack.webhooks'
      Value: !Ref SlackApprovalsWebhook
      Description: Webhook URL for approvals notifications
      Type: 'SecureString'
      Overwrite: True
  SlackNotificationsLambda:
    Type: AWS::Lambda::Function
    DependsOn: MyKeyAlias
    Condition: cEnableSlackApprovals
    Properties:
      FunctionName: !Sub '${AWS::StackName}-slack-notifications'
      Description: |
        Lambda Function to send approvals notifications to slcak channel
      Handler: index.handler
      Role: !GetAtt 'SlackLambdaRole.Arn'
      Code:
        ZipFile: |
          'use strict';
          const AWS = require('aws-sdk');
          const url = require('url');
          const https = require('https');

          // The base-64 encoded, encrypted key (CiphertextBlob) stored in the kmsEncryptedHookUrl environment variable
          const kmsEncryptedHookUrl = process.env.kmsEncryptedHookUrl;
          // The Slack channel to send a message to stored in the slackChannel environment variable
          const slackChannel = process.env.slackChannel;
          let hookUrl;


          function postMessage(message, callback) {
          	const body = JSON.stringify(message);
          	const options = url.parse(hookUrl);
          	options.method = 'POST';
          	options.headers = {
          		'Content-Type': 'application/json',
          		'Content-Length': Buffer.byteLength(body),
          	};

          	const postReq = https.request(options, (res) => {
          		const chunks = [];
          		res.setEncoding('utf8');
          		res.on('data', (chunk) => chunks.push(chunk));
          		res.on('end', () => {
          			if (callback) {
          				callback({
          					body: chunks.join(''),
          					statusCode: res.statusCode,
          					statusMessage: res.statusMessage,
          				});
          			}
          		});
          		return res;
          	});

          	postReq.write(body);
          	postReq.end();
          }

          function processEvent(event, callback) {
          	const message = JSON.parse(event.Records[0].Sns.Message);

          	const alarmName = message.AlarmName;
          	//var oldState = message.OldStateValue;
          	const newState = message.NewStateValue;
          	const reason = message.NewStateReason;

          	const slackMessage = {
          		"text": `Pipeline "${message.approval.pipelineName}" approval required, action "${message.approval.actionName}"`,
          		"attachments": [
          		{
          			"author_name": "Cloud Platform AWS approval",
          			"author_icon": "https://i0.wp.com/reillytop10.com/wp-content/uploads/2016/12/Screen-Shot-2016-12-12-at-3.42.49-PM.png",
          			"image_url": [
          				"https://media.giphy.com/media/3o7abrH8o4HMgEAV9e/giphy.gif",
          				"https://media.giphy.com/media/UsmcxQeK7BRBK/giphy.gif",
          				"https://media.giphy.com/media/QynHhYJiwfoJO/giphy.gif",
          				"https://media.giphy.com/media/Dih5LeyxL8fny/giphy.gif",
          			][Math.floor((Math.random() * 4))]
          		},
          		{
          			"text": `${message.approval.customData}`,
          			"fields": [
          			{
          				"title": "Approval link",
          				"value": `${message.approval.approvalReviewLink}`,
          				"short": true,
          			},
          			]
          		},
          		{
          			"fields": [
          			{
          				"title": "Pipeline",
          				"value": `${message.consoleLink}`,
          				"short": true,
          			},
          			]
          		}
          		]
          	}

          	postMessage(slackMessage, (response) => {
          		if (response.statusCode < 400) {
          			console.info('Message posted successfully');
          			callback(null);
          		} else if (response.statusCode < 500) {
          			console.error(`Error posting message to Slack API: ${response.statusCode} - ${response.statusMessage}`);
          			callback(null);  // Don't retry because the error is due to a problem with the request
          		} else {
          			// Let Lambda retry
          			callback(`Server error when processing message: ${response.statusCode} - ${response.statusMessage}`);
          		}
          	});
          }

          exports.handler = (event, context, callback) => {
          	return new Promise((resolve, reject) => {
          		if (hookUrl) {
          			return resolve(hookUrl)
          		}

          		const ssm = new AWS.SSM()
          		return ssm.getParameters({
          			Names: ['pm.slack.webhooks'],
          			WithDecryption: true
          		}).promise()
          		.then((data) => {
          			hookUrl = data.Parameters[0].Value;
          		})
          		.then(resolve)
          	})
          	.then(() => {
          		processEvent(event, callback);
          	})
          	.catch(callback)
          };
      Runtime: nodejs6.10
      Timeout: 25
  SlackNotificationsLambdaPermission:
    Type: AWS::Lambda::Permission
    Condition: cEnableSlackApprovals
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SlackNotificationsLambda
      Principal: !Sub 'sns.amazonaws.com'
      SourceArn: !Ref ApprovalTopic
  SlackNotificationsApprovalSubscription:
    Type: AWS::SNS::Subscription
    Condition: cEnableSlackApprovals
    Properties:
      Endpoint: !Sub '${SlackNotificationsLambda.Arn}'
      Protocol: lambda
      TopicArn: !Ref ApprovalTopic
